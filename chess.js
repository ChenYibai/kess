var n = 9, // Board size
  m = 9; // Number of pieces per team
var board = []; // Each element is generated by newPiece()
var nam = ["姚", "姚", "华", "华", "马", "马", "猴", "猴", "王"];
var initPos = [[0, 0], [0, 8], [0, 1], [0, 7], [1, 0], [1, 8], [1, 2], [1, 6], [0, 4]];
var initBlood = 10, initAttack = 3;
// supplySprite: [[x, y, weight], ...]
// x, y indicate the icon's position in sprite.png
var supplySprite = [[20, 113, 1], // 0 Iron Sword
[19, 113, 1], // 1 Golden Sword
[18, 113, 1], // 2 Diamond Sword
[15, 78, 1], // 3 Iron Chestplate
[9, 78, 1], // 4 Golden Chestplate
[4, 78, 1], // 5 Diamond Chestplate
[30, 112, 1], // 6 TNT
[7, 9, 1], // 7 Potion of Healing
[17, 9, 1], // 8 Potion of Swiftness
[16, 9, 1], // 9 Potion of Strength
[23, 30, 1], // 10 Ice
[21, 109, 1], // 11 Ender Pearl
[30, 104, 5], // 12 Cobblestone
[5, 101, 2], // 13 Iron Block
];
var supplyW = supplySprite.reduce((p, c) => (p + c[2]), 0);
var genSupplyP = 0.33; // Probability of generating supply after each go
var swordAttack = [5, 7, 9],
  armorDefence = [1, 2, 4]; // [Iron, Golden, Diamond]

var player = 0;
var going = 0;
var killedi = 0, killedii = 0;
var turn = 0; // number of goes made up to now
var reviveList = []; // List of pieces waiting to be revived. Format: [[newPiece(), time]]

// Basic helper functions
function cAlert(html) {
  $(document.body).append(`<div class="modal fade" id="cAlert" tabindex="-1">
    <div class="modal-dialog"><div class="modal-content">
    <div class="modal-body" style="text-align:center">${html}</div>
    <div class="modal-footer">
    <button type="button" class="btn btn-secondary" data-dismiss="modal">Confirm</button>
    </div></div></div></div>`);
  $("#cAlert").modal("show").on("shown.bs.modal", function () {
    $("#cAlert .btn-secondary").trigger("focus");
  });
  return new Promise(function (resolve, reject) {
    $("#cAlert").on("hidden.bs.modal", function () {
      $("#cAlert").remove();
      resolve();
    });
  });
}
function pos(x, y) {
  return `top: ${Number(x) * 50}px; left: ${Number(y) * 50}px; `;
}
function posObj(x, y) {
  return { "top": `${Number(x) * 50}px`, "left": `${Number(y) * 50}px` };
}
function spriteCss(l, s) {
  var x = l[0], y = l[1];
  return `background-image:url(img/sprite.png);
    background-position: ${- x * s}px ${- y * s}px;
    background-size: ${s * 32}px;
    width: ${s}px;
    height: ${s}px;
    display: inline-block;
    image-rendering: crisp-edges;`;
}
function spriteCssObj(l, s) {
  var x = l[0], y = l[1];
  return {
    "background-image": "url(img/sprite.png)",
    "background-position": `${- x * s}px ${- y * s}px`,
    "background-size": `${s * 32}px`,
    "width": `${s}px`,
    "height": `${s}px`,
    "display": "inline-block",
    "image-rendering": "crisp-edges"
  };
}
function blockSpriteCss(l, s) {
  var x = l[0], y = l[1];
  return `background-image:url(img/blocksprite.png);
    background-position: ${- x * s}px ${- y * s}px;
    background-size: ${s * 24}px;
    width: ${s}px;
    height: ${s}px;
    image-rendering: crisp-edges;`;
}
function blockSpriteCssObj(l, s) {
  var x = l[0], y = l[1];
  return {
    "background-image": "url(img/blocksprite.png)",
    "background-position": `${- x * s}px ${- y * s}px`,
    "background-size": `${s * 24}px`,
    "width": `${s}px`,
    "height": `${s}px`,
    "image-rendering": "crisp-edges"
  };
}
function newPiece(obj) {
  var init = {
    team: 0, level: 0,
    armor: 0, attack: initAttack, blood: initBlood, item: [],
    potionSwiftness: 0, potionStrength: 0,
    frozen: 0
  };
  $.extend(init, obj);
  return init;
}
function inBoard(x, y) {
  return (x >= 0 && x < n && y >= 0 && y < n);
}
function $cell(x, y) {
  return $("#board>tr").eq(x).children("td").eq(y);
}
function $piece(x, y) {
  return $(`#piece${board[x][y].team * 16 + board[x][y].level}`);
}
function dataSupply(x, y) {
  return Number($cell(x, y).attr("data-supply"));
}
function dataBlock(x, y) {
  return Number($cell(x, y).attr("data-block"));
}

window.onload = function () {
  let ht = "";
  for (let i = 0; i < n; i++) {
    ht += "<tr>";
    for (let i = 0; i < n; i++) ht += '<td data-supply="-1" data-block="-1"></td>';
    ht += "</tr>";
  }
  $("#board").html(ht);

  for (var i = 0; i < n; i++) {
    board.push([]);
    for (var j = 0; j < n; j++)
      board[i].push(-1);
  }

  for (let i = 0; i < m; i++) {
    let xI = n - 1 - initPos[i][0], yI = n - 1 - initPos[i][1];
    let nameI = nam[i];
    document.body.innerHTML += `<div class="piece teami" id="piece${i}"
      style="${pos(xI, yI)}" onclick="control(${xI}, ${yI})"
      onmouseover="infoBox(${xI}, ${yI})"
      onmouseout="clearInfoBox()">${nameI}</div>`;
    board[xI][yI] = newPiece({ team: 0, level: i });
  }
  for (let i = 0; i < m; i++) {
    let xI = initPos[i][0], yI = initPos[i][1];
    let nameI = nam[i];
    document.body.innerHTML += `<div class="piece teamii" id="piece${String(Number(i) + 16)}"
      style="${pos(xI, yI)}" onclick="control(${xI}, ${yI})"
      onmouseover="infoBox(${xI}, ${yI})"
      onmouseout="clearInfoBox()">${nameI}</div>`;
    board[xI][yI] = newPiece({ team: 1, level: i });
  }

  $(".piece").append(`<div class="sword-img"></div><div class="armor-img"></div>`);
}

// Show/hide info box
function infoBox(x, y) {
  if (going) return;
  $("#blood").empty();
  $("#item").empty();
  let boardXY = board[x][y];
  if (boardXY.frozen) return;
  document.getElementById("control-name").innerHTML = nam[boardXY.level];
  for (let i = 1; i * 2 <= boardXY.blood; i++)
    $("#blood").append(`<img src="img/heart.png" style="width: 20px">`);
  if (boardXY.blood % 2)
    $("#blood").append(`<img src="img/heart-half.png" style="width: 20px">`);
  for (var item of boardXY.item)
    $("#item").append(`<div style="${spriteCss(supplySprite[item], 20)}"
      class="item-img" onclick="useItem(${item}, ${x}, ${y})"></div>`);
  $("#control").show();
}
function clearInfoBox() {
  if (going) return;
  $("#control").hide();
}

// Check if a cell is empty
function emptyQ(nx, ny) {
  return inBoard(nx, ny) && board[nx][ny] == -1 && dataBlock(nx, ny) == -1;
}
// Check if a cell is valid to land on
function landingQ(x, y, nx, ny) {
  return inBoard(nx, ny) &&
    (board[nx][ny] == -1 || board[nx][ny].team != player) &&
    (dataBlock(nx, ny) == -1 ||
      dataBlock(nx, ny) == 12 && board[x][y].attack >= swordAttack[0] ||
      dataBlock(nx, ny) == 13 && board[x][y].attack >= swordAttack[2]);
}
// Check if a cell is valid to pass
function passingQ(x, y, nx, ny) {
  return inBoard(nx, ny) &&
    board[nx][ny] == -1 &&
    dataBlock(nx, ny) == -1;
}
// Render a clickable square
function controlHelper(x, y, nx, ny) {
  if (!inBoard(nx, ny)) return;
  if (board[nx][ny].team == player) return;
  if (emptyQ(nx, ny))
    $("#go").append(`<div class="go-empty" onclick="go(${x},${y},${nx},${ny})"
      style="${pos(nx, ny)}"></div>`);
  else if (board[nx][ny].team != player || dataBlock(nx, ny) != 1) {
    $("#go").append(`<div class="go-kill" onclick="go(${x},${y},${nx},${ny})"
      style="${pos(nx, ny)}"></div>`);
  }
}
// Compute where a piece can go and render all the clickable squares
function control(x, y) {
  let boardXY = board[x][y];
  if (boardXY.frozen) return;
  if (player == boardXY.team && going == 0) {
    going = 2;
    // Compute where the piece can go and store the destinations in `res`
    var res = [];
    switch (boardXY.level) {
      case 0:
      case 1:
        var dx = [-1, 0, 1, 0], dy = [0, -1, 0, 1];
        for (let d = 0; d < 4; d++) {
          let nx = Number(x) + Number(dx[d]), ny = Number(y) + Number(dy[d]);
          while (passingQ(x, y, nx, ny)) {
            res.push([nx, ny]);
            nx += dx[d], ny += dy[d];
          }
          if (landingQ(x, y, nx, ny))
            res.push([nx, ny]);
        }
        break;
      case 2:
      case 3:
        var dx = [-1, -1, 1, 1], dy = [-1, 1, -1, 1];
        for (let d = 0; d < 4; d++) {
          let nx = Number(x) + Number(dx[d]), ny = Number(y) + Number(dy[d]);
          while (passingQ(x, y, nx, ny)) {
            res.push([nx, ny]);
            nx += dx[d], ny += dy[d];
          }
          if (landingQ(x, y, nx, ny))
            res.push([nx, ny]);
        }
        dx = [1, -1, 0, 0], dy = [0, 0, 1, -1];
        for (let d = 0; d < 4; d++) {
          let nx = Number(x) + dx[d], ny = Number(y) + dy[d];
          if (landingQ(x, y, nx, ny))
            res.push([nx, ny]);
        }
        break;
      case 4:
      case 5:
        var dx = [1, -1, 1, -1, 2, -2, 2, -2, 1, -1, 0, 0],
          dy = [2, 2, -2, -2, 1, 1, -1, -1, 0, 0, 1, -1];
        for (let d = 0; d < 12; d++) {
          let nx = Number(x) + Number(dx[d]), ny = Number(y) + Number(dy[d]);
          if (landingQ(x, y, nx, ny))
            res.push([nx, ny]);
        }
        break;
      case 6:
      case 7:
        // Standard BFS
        var dx = [1, -1, 0, 0], dy = [0, 0, 1, -1];
        var queue = [[x, y, 0]];
        var vis = new Map([[x * 1000 + y, true]]);
        while (queue.length != 0) {
          // Pop the head element of queue
          var node = queue[0];
          var x0 = node[0], y0 = node[1], t0 = node[2];
          queue.splice(0, 1);
          // Push new elements into queue
          for (let d = 0; d < 4; d++) {
            let nx = x0 + dx[d], ny = y0 + dy[d], nt = t0 + 1;
            // Visitedness check
            if (vis.has(nx * 1000 + ny)) continue;
            // Process
            vis.set(nx * 1000 + ny, true);
            if (landingQ(x, y, nx, ny))
              res.push([nx, ny]);
            // Push element
            if ((passingQ(x, y, nx, ny) || dataBlock(nx, ny) == 12) && nt <= 1) {
              queue.push([nx, ny, nt]);
            }
          }
        }
        break;
      case 9:
      case 10:
      case 11:
        var dx = [1, -1, 0, 0], dy = [0, 0, 1, -1];
        for (let d = 0; d < 4; d++) {
          let nx = Number(x) + dx[d], ny = Number(y) + dy[d];
          if (landingQ(x, y, nx, ny))
            res.push([nx, ny]);
        }
        break;
    }
    // Process effect of swiftness
    if (boardXY.potionSwiftness) {
      var dx = [1, -1, 0, 0], dy = [0, 0, 1, -1];
      var queue = [[x, y, 0]];
      var vis = new Map([[x * 1000 + y, true]]);
      while (queue.length != 0) {
        // Pop the head element of queue
        var node = queue[0];
        var x0 = node[0], y0 = node[1], t0 = node[2];
        queue.splice(0, 1);
        // Push new elements into queue
        for (let d = 0; d < 4; d++) {
          let nx = x0 + dx[d], ny = y0 + dy[d], nt = t0 + 1;
          // Visitedness check
          if (vis.has(nx * 1000 + ny)) continue;
          // Process
          vis.set(nx * 1000 + ny, true);
          if (landingQ(x, y, nx, ny))
            res.push([nx, ny]);
          // Push element
          if ((passingQ(x, y, nx, ny)) && nt <= 2) {
            queue.push([nx, ny, nt]);
          }
        }
      }
    }
    // Render the clickable green(or other colors) squares
    for (var point of res) controlHelper(x, y, point[0], point[1]);
  }
  if (going == 1) {
    $("#go").empty();
    going = 0;
  }
  if (going == 2) going = 1;
}

// The 3 functions below are just for displaying.
// They don't change the value of `board`, so you should change it manually.
// Just to move a piece without considering anything else
function movePiece(x, y, nx, ny) {
  var bxy = board[x][y];
  var ele = document.getElementById("piece" + String(Number(bxy.team) * 16 + Number(bxy.level)));
  ele.onclick = function () {
    control(nx, ny);
  };
  ele.onmouseover = function () {
    infoBox(nx, ny);
  };
  $(ele).css(posObj(nx, ny));
}
// Display a piece as dead (put it out of the board)
var killPiecePos = 0;
var kingAlive = [1, 1]; // kingAlive[team] = if king of the team is alive
var killedNum = [0, 0]; // killedNum[team] = number of killed pieces of the team
function killPiece(x, y) {
  var bxy = board[x][y];
  var ele = document.getElementById("piece" + String(Number(bxy.team) * 16 + Number(bxy.level)));
  if (bxy.level == 8) kingAlive[bxy.team] = 0;
  if (kingAlive[bxy.team])
    $(ele).css(posObj((killPiecePos++) % n, n + 1));
  else
    $(ele).css("display", "none");
  ele.onclick = function () { };
  ele.onmouseover = function () { };
  $(ele).children(".sword-img").css("background", "none");
  $(ele).children(".armor-img").css("background", "none");
  $cell(x, y).empty();
  if (kingAlive[bxy.team])
    reviveList.push([bxy, 5]); // `5` means reviving after 5 goes
  else killedNum[bxy.team]++;

  if (killedNum[0] == m) cAlert("<h2>Blue wins!</h2>");
  if (killedNum[1] == m) cAlert("<h2>Red wins!</h2>");
}
// Display a piece as alive (put it back in the board)
function revivePiece(i, nx, ny) {
  // if (bxy[0] == 0) killedi--;
  // else killedii--;
  var bxy = reviveList[i][0];
  var ele = document.getElementById("piece" + String(Number(bxy.team) * 16 + Number(bxy.level)));
  $(ele).css(posObj(nx, ny));
  ele.onclick = function () {
    control(nx, ny);
  };
  ele.onmouseover = function () {
    infoBox(nx, ny);
  }
  reviveList.splice(i, 1);
  pickUp(nx, ny, nx, ny);
}

// Perform general operations necessary after using a item
function afterItem() {
  $("#go").empty();
  $("#control").fadeOut();
  going = 0;
}
// Perform general operations necessary after each go
function afterGo() {
  afterItem();

  player = 1 - player;
  if (player == 0) document.getElementById("player").style.background = "red";
  else document.getElementById("player").style.background = "blue";

  // Generate supply
  turn++;
  if (Math.random() < genSupplyP) {
    var pt, px, py; // Type, X, Y (X, Y indicate its position in the board)
    // Generate pt(type) according to the weights
    var t = Math.floor(Math.random() * supplyW);
    for (var i in supplySprite)
      if (t >= supplySprite[i][2]) t -= supplySprite[i][2];
      else { pt = Number(i); break; }
    // Generate px, py(position)
    var cnt = 0;
    do {
      px = Math.floor(Math.random() * 9);
      py = Math.floor(Math.random() * 9);
      cnt++;
    } while ((!emptyQ(px, py) || dataSupply(px, py) != -1) && cnt < 100);
    if (cnt < 18) {
      $cell(px, py).attr("data-supply", pt)
        .html(`<div style="${spriteCss(supplySprite[pt], 36)}margin:auto;"></div>`);
    }
  }

  // Revive pieces
  for (var i in reviveList) {
    var item = reviveList[i];
    item[1]--;
    if (item[1] == 0) {
      var rx, ry;
      if (item[0].team == 0) {
        rx = n - 1, ry = n - 1;
        while (!emptyQ(rx, ry)) {
          ry--;
          if (ry == -1) ry = n - 1, rx--;
        }
      }
      else {
        rx = 0, ry = 0;
        while (!emptyQ(rx, ry)) {
          ry++;
          if (ry == n) ry = 0, rx++;
        }
      }
      board[rx][ry] = newPiece({ team: item[0].team, level: item[0].level });
      revivePiece(i, rx, ry);
    }
  }

  // Decrease buff(from potions) duration
  for (var i = 0; i < n; i++) for (var j = 0; j < n; j++) if (board[i][j] != -1) {
    board[i][j].potionSwiftness = Math.max(0, board[i][j].potionSwiftness - 1);
    board[i][j].potionStrength = Math.max(0, board[i][j].potionStrength - 1);
    board[i][j].frozen = Math.max(0, board[i][j].frozen - 1);
    if (board[i][j].frozen == 0) $cell(i, j).children(".frozen-img").remove();
  }
}

// The piece on (x, y) picks up supply on (nx, ny)
function pickUp(x, y, nx, ny) {
  var supply = dataSupply(nx, ny);
  if (supply != -1) {
    if (supply >= 0 && supply <= 2) { // Sword
      if (swordAttack[supply] > board[x][y].attack) {
        board[x][y].attack = swordAttack[supply];
        // Display it on the piece
        $piece(x, y).children(".sword-img").css(spriteCssObj(supplySprite[supply], 15));
      }
    }
    else if (supply >= 3 && supply <= 5) { // Armor
      if (armorDefence[supply - 3] > board[x][y].armor) {
        board[x][y].armor = armorDefence[supply - 3];
        $piece(x, y).children(".armor-img").css(spriteCssObj(supplySprite[supply], 15));
      }
    }
    else { // Item
      board[x][y].item.push(supply);
    }
    $cell(nx, ny).attr("data-supply", -1).html("");
  }
}

// Move a piece from (x, y) to (nx, ny)
function go(x, y, nx, ny) {
  let bxy = board[x][y], nbxy = board[nx][ny];
  if (emptyQ(nx, ny)) { // Steps into empty square
    movePiece(x, y, nx, ny);
    pickUp(x, y, nx, ny);
    board[nx][ny] = board[x][y];
    board[x][y] = -1;
  }
  else if (nbxy != -1) { // Attack another piece
    board[nx][ny].blood -= Math.max(1, board[x][y].attack
      + (board[x][y].potionStrength ? 2 : 0) - board[nx][ny].armor);
    nbxy = board[nx][ny]; bxy = board[x][y];
    if (nbxy.blood <= 0) { // Knock Out
      killPiece(nx, ny);
      bxy.attack = Math.max(bxy.attack, nbxy.attack), nbxy.attack = 0; // Transfer sword
      if (bxy.attack > 3)
        $piece(x, y).children(".sword-img").css(spriteCssObj(supplySprite[swordAttack.indexOf(bxy.attack)], 15));
      bxy.armor = Math.max(bxy.armor, nbxy.armor), nbxy.armor = 0; // Transfer armor
      if (bxy.armor > 0)
        $piece(x, y).children(".armor-img").css(spriteCssObj(supplySprite[armorDefence.indexOf(bxy.armor) + 3], 15));
      bxy.item = bxy.item.concat(nbxy.item); // Transfer item
      movePiece(x, y, nx, ny);
      board[x][y] = -1; board[nx][ny] = bxy;
    }
    // Still alive; Knockback; 王 and frozen pieces cannot be knocked back
    else if (board[nx][ny].level != 8 && !board[nx][ny].frozen) {
      var kb = [0, 0];
      var sign = (x) => (x > 0 ? 1 : (x == 0 ? 0 : -1));
      kb[0] = sign(nx - x), kb[1] = sign(ny - y);
      var kbnx = nx + kb[0], kbny = ny + kb[1];
      if (emptyQ(kbnx, kbny)) {
        movePiece(nx, ny, kbnx, kbny);
        pickUp(nx, ny, kbnx, kbny);
        board[kbnx][kbny] = board[nx][ny], board[nx][ny] = -1;
      }
    }
  }
  else if (dataBlock(nx, ny) != -1) {
    $cell(nx, ny).css("background", "none").attr("data-block", "-1");
  }
  afterGo();
}

// Put a block whose ID is `b` on (x, y)
var blockSprite = new Map([[12, [2, 52]], [13, [8, 58]]]);
function build(x, y, b) {
  $cell(x, y).empty().css(blockSpriteCssObj(blockSprite.get(b), 50))
    .attr("data-block", b);
  afterItem();
}

function useItem(item, x, y) {
  switch (item) {
    case 6:
      for (var i = 0; i < n; i++) for (var j = 0; j < n; j++) {
        var dist = (i - x) * (i - x) + (j - y) * (j - y);
        if (dist <= 10 && board[i][j] != -1) {
          // TNT explosion destroys ice (regardless of its team)
          if (board[i][j].frozen) {
            board[i][j].frozen = 0;
            $cell(i, j).empty();
          }
          // TNT hurts enemy's pieces
          if (board[i][j].team != board[x][y].team) {
            board[i][j].blood -= Math.max(1, 11 - dist - board[i][j].armor);
            if (board[i][j].blood <= 0) {
              killPiece(i, j);
              board[i][j] = -1;
            }
          }
        }
      }
      afterGo();
      break;
    case 7:
      board[x][y].blood = 10;
      afterItem();
      break;
    case 8:
      board[x][y].potionSwiftness = 8;
      afterItem();
      break;
    case 9:
      board[x][y].potionStrength = 8;
      afterItem();
      break;
    case 10:
      var dx = [1, 1, 1, 0, 0, -1, -1, -1], dy = [1, 0, -1, 1, -1, 1, 0, -1];
      for (var i = 0; i < 8; i++) {
        var nx = x + dx[i], ny = y + dy[i];
        if (inBoard(nx, ny) && board[nx][ny] != -1
          && board[nx][ny].team != board[x][y].team) {
          board[nx][ny].frozen += 8;
          // If there is supply on this square, it will disappear
          $cell(nx, ny).html(`<img class="frozen-img" src="img/frozen.png">`);
        }
      }
      afterGo();
      break;
    case 11:
      $("#go").empty();
      $("#control").fadeOut();
      for (var i = 0; i < n; i++) for (var j = 0; j < n; j++)
        if (emptyQ(i, j))
          controlHelper(x, y, i, j);
      break;
    case 12:
    case 13:
      $("#control").fadeOut();
      $(".go-empty").each(function () {
        $(this).removeClass("go-empty").addClass("go-build");
        var orig = $(this).attr("onclick");
        var pres = orig.replace(/^go\(\d*,\d*,(\d*),(\d*)\)$/ig, `build($1,$2,${item})`);
        $(this).attr("onclick", pres);
      });
      $(".go-kill").remove();
      break;
  }

  // Remove the item from the piece's "item" property
  for (var i = 0; i < board[x][y].item.length; i++)
    if (board[x][y].item[i] == item) {
      board[x][y].item.splice(i, 1);
      break;
    }
}

function giveUp() {
  if (player == 0) {
    cAlert("<h2>Blue Wins!</h2>");
  }
  else {
    cAlert("<h2>Red Wins!</h2>");
  }
}

function assess() {
  var res = [kingAlive[0] * 400, kingAlive[1] * 400];
  var weight = [100, 100, 110, 110, 45, 45, 110, 110, 600];
  for (var i = 0; i < n; i++) for (var j = 0; j < n; j++) {
    if (board[i][j] == -1) continue;
    var t = board[i][j].team;
    var wt = weight[board[i][j].level] * (board[i][j].blood / 10);
    res[t] += wt;
    res[t] += Math.max(0, wt * 0.18 * (board[i][j].attack - 4));
    res[t] += wt * 0.23 * (board[i][j].armor);
    var tmp = [0, 0, 0, 0, 0]; // [Dummy, #6, #7, #8+#9, #10]
    for (var item of board[i][j].item)
      tmp[[0, 0, 0, 0, 0, 0, 1, 2, 3, 3, 4][item]]++;
    res[t] += (Math.min(tmp[1] * 15, 55) + tmp[2] * 60
      + Math.min(tmp[3] * 10, 35) + Math.min(tmp[4] * 8, 15));
  }
  for (var item of reviveList) {
    res[item.team] += weight[item.level] * 0.8;
  }
  res = res.map((x) => (Math.round(x * 10) / 10));
  cAlert(`当前局面评估结果：<br>
  <b style="color:red">${res[0]}</b>：<b style="color:blue">${res[1]}</b><br>
  若现在结束比赛，可判${res[0] > res[1] ? "红胜" : (res[0] < res[1] ? "蓝胜" : "平")}。`);
}