var n = 9, // Board size
  m = 9; // Number of pieces per team
var board = []; // Each element is generated by newPiece()
var alterBoard = []; // Alternative board; The board which is not currently shown
var alterHTML = "";  // HTML of the alternative board
var nam = ["姚", "姚", "华", "华", "马", "马", "猴", "猴", "王"];
var initPos = [[0, 0], [0, 8], [0, 1], [0, 7], [0, 2], [0, 6], [0, 3], [0, 5], [0, 4]];
var initBlood = 8, initAttack = 5;
// supplySprite: [[x, y, weight], ...]
// x, y indicate the icon's position in sprite.png
var supplySprite = [[20, 113, 1], // 0 Iron Sword
[19, 113, 1], // 1 Golden Sword
[18, 113, 1], // 2 Diamond Sword
[15, 78, 1], // 3 Iron Chestplate
[9, 78, 1], // 4 Golden Chestplate
[4, 78, 1], // 5 Diamond Chestplate
[30, 112, 1], // 6 TNT
[7, 9, 1], // 7 Potion of Healing
[17, 9, 1], // 8 Potion of Swiftness
[16, 9, 1], // 9 Potion of Strength
[23, 30, 1], // 10 Ice
[21, 109, 1], // 11 Ender Pearl
[7, 105, 2], // 12 Mossy Stone Bricks
[5, 27, 1], // 13 Bricks
[13, 109, 0] // 14 Bone
];
var supplyW = supplySprite.reduce((p, c) => (p + c[2]), 0);
var genSupplyP = 1; // Probability of generating supply after each go
var numJason = 1, // Number of Jasons
  posJason = [[0, 0]]; // Initial positions of Jasons
var swordAttack = [8, 9, 10],
  armorDefence = [1, 2, 3]; // [Iron, Golden, Diamond]

var player = 0;
var going = 0;
var turn = 0; // number of goes made up to now
var reviveList = [[], []]; // List of pieces waiting to be revived. reviveList[world][i] = {Piece(), time}
var curWorld = 0; // Current world shown. 0 = Overworld; 1 = Nether

// Basic helper functions
function cAlert(html) {
  $(document.body).append(`<div class="modal fade" id="cAlert" tabindex="-1">
    <div class="modal-dialog"><div class="modal-content">
    <div class="modal-body" style="text-align:center">${html}</div>
    <div class="modal-footer">
    <button type="button" class="btn btn-secondary" data-dismiss="modal">Confirm</button>
    </div></div></div></div>`);
  $("#cAlert").modal("show").on("shown.bs.modal", function () {
    $("#cAlert .btn-secondary").trigger("focus");
  });
  return new Promise(function (resolve, reject) {
    $("#cAlert").on("hidden.bs.modal", function () {
      $("#cAlert").remove();
      resolve();
    });
  });
}
function pos(x, y) {
  return `top: ${Number(x) * 50}px; left: ${Number(y) * 50}px; `;
}
function posObj(x, y) {
  return { "top": `${Number(x) * 50}px`, "left": `${Number(y) * 50}px` };
}
function spriteCss(l, s) {
  var x = l[0], y = l[1];
  return `background-image:url(img/sprite.png);
    background-position: ${- x * s}px ${- y * s}px;
    background-size: ${s * 32}px;
    width: ${s}px;
    height: ${s}px;
    display: inline-block;
    image-rendering: crisp-edges;`;
}
function spriteCssObj(l, s) {
  var x = l[0], y = l[1];
  return {
    "background-image": "url(img/sprite.png)",
    "background-position": `${- x * s}px ${- y * s}px`,
    "background-size": `${s * 32}px`,
    "width": `${s}px`,
    "height": `${s}px`,
    "display": "inline-block",
    "image-rendering": "crisp-edges"
  };
}
function blockSpriteCss(l, s) {
  var x = l[0], y = l[1];
  return `background-image:url(img/blocksprite.png);
    background-position: ${- x * s}px ${- y * s}px;
    background-size: ${s * 24}px;
    width: ${s}px;
    height: ${s}px;
    image-rendering: crisp-edges;`;
}
function blockSpriteCssObj(l, s) {
  var x = l[0], y = l[1];
  return {
    "background-image": "url(img/blocksprite.png)",
    "background-position": `${- x * s}px ${- y * s}px`,
    "background-size": `${s * 24}px`,
    "width": `${s}px`,
    "height": `${s}px`,
    "image-rendering": "crisp-edges"
  };
}
function newPiece(obj) {
  var init = {
    team: 0, level: 0,
    armor: 0, attack: initAttack, blood: initBlood, item: [],
    potionSwiftness: 0, potionStrength: 0,
    frozen: 0
  };
  $.extend(init, obj);
  return init;
}
function inBoard(x, y) {
  return (x >= 0 && x < n && y >= 0 && y < n);
}
function $cell(x, y) {
  return $("#board>tr").eq(x).children("td").eq(y);
}
function $piece(x, y) {
  return $(`#piece${board[x][y].team * 16 + board[x][y].level}`);
}
function dataSupply(x, y) {
  return Number($cell(x, y).attr("data-supply"));
}
function dataBlock(x, y) {
  return Number($cell(x, y).attr("data-block"));
}

window.onload = function () {
  // Init board HTML
  let ht = "";
  for (let i = 0; i < n; i++) {
    ht += "<tr>";
    for (let i = 0; i < n; i++) ht += '<td data-supply="-1" data-block="-1"></td>';
    ht += "</tr>";
  }
  $("#board").html(ht);
  alterHTML = ht;
  for (var j = 0; j < n; j++) build(4, j, 12);

  // Init "board" variable
  for (var i = 0; i < n; i++) {
    board.push([]);
    alterBoard.push([]);
    for (var j = 0; j < n; j++)
      board[i].push(-1), alterBoard[i].push(-1);
  }

  // Init pieces HTML
  for (let i = 0; i < m; i++) {
    let xI = n - 1 - initPos[i][0], yI = n - 1 - initPos[i][1];
    let nameI = nam[i];
    document.body.innerHTML += `<div class="piece teami" id="piece${i}"
      data-world="0" style="${pos(xI, yI)}"
      onclick="control(${xI}, ${yI})"
      onmouseover="infoBox(${xI}, ${yI})"
      onmouseout="clearInfoBox()">${nameI}</div>`;
    board[xI][yI] = newPiece({ team: 0, level: i });
  }
  for (let i = 0; i < m; i++) {
    let xI = initPos[i][0], yI = initPos[i][1];
    let nameI = nam[i];
    document.body.innerHTML += `<div class="piece teamii" id="piece${i + 16}"
      data-world="0" style="${pos(xI, yI)}"
      onclick="control(${xI}, ${yI})"
      onmouseover="infoBox(${xI}, ${yI})"
      onmouseout="clearInfoBox()">${nameI}</div>`;
    board[xI][yI] = newPiece({ team: 1, level: i });
  }
  $(".piece").append(`<div class="sword-img"></div><div class="armor-img"></div>`);

  // Initialize the Nether: Jasons and Nether Portal
  toggleWorld();
  for (let i = 0; i < numJason; i++) {
    var spx = posJason[i][0], spy = posJason[i][1];
    board[spx][spy] = newPiece({ team: 2, level: i });
    $("#jason-piece").append(`<div class="piece teamj" id="piece${32 + i}"
    data-world="1" style="${pos(spx, spy)}"
    onmouseover="infoBox(${spx}, ${spy})"
    onmouseout="clearInfoBox()">贾
    <div class="sword-img"></div><div class="armor-img"></div></div>`);
    giveSupply(spx, spy, 4);
  }
  build(4, 4, 0);
  toggleWorld();
}

// Show/hide info box
function infoBox(x, y) {
  if (going) return;
  $("#blood").empty();
  $("#item").empty();
  let boardXY = board[x][y];
  if (boardXY.frozen) return;
  $("#control-name").html(boardXY.team == 2 ? "贾" : nam[boardXY.level]);
  for (let i = 1; i * 2 <= boardXY.blood; i++)
    $("#blood").append(`<img src="img/heart.png" style="width: 20px">`);
  if (boardXY.blood % 2)
    $("#blood").append(`<img src="img/heart-half.png" style="width: 20px">`);
  for (var item of boardXY.item)
    $("#item").append(`<div style="${spriteCss(supplySprite[item], 20)}"
      class="item-img" onclick="useItem(${item}, ${x}, ${y})"></div>`);
  $("#control").show();
}
function clearInfoBox() {
  if (going) return;
  $("#control").hide();
}

// Check if a cell is empty
function emptyQ(nx, ny) {
  return inBoard(nx, ny) && board[nx][ny] == -1 && dataBlock(nx, ny) == -1;
}
// Check if a cell is valid to land on
function landingQ(x, y, nx, ny) {
  return inBoard(nx, ny) &&
    (board[nx][ny] == -1 || board[nx][ny].team != player) &&
    (dataBlock(nx, ny) == -1 ||
      dataBlock(nx, ny) == 0 ||
      dataBlock(nx, ny) == 12 && board[x][y].attack >= swordAttack[0] ||
      dataBlock(nx, ny) == 13 && board[x][y].attack >= swordAttack[2]);
}
// Check if a cell is valid to pass
function passingQ(x, y, nx, ny) {
  return inBoard(nx, ny) &&
    board[nx][ny] == -1 &&
    (dataBlock(nx, ny) == -1 || dataBlock(nx, ny) == 0);
}
// Render a clickable square
function controlHelper(x, y, nx, ny) {
  if (!inBoard(nx, ny)) return;
  if (board[nx][ny].team == player) return;
  if (emptyQ(nx, ny) || dataBlock(nx, ny) == 0)
    $("#go").append(`<div class="go-empty" onclick="go(${x},${y},${nx},${ny})"
      style="${pos(nx, ny)}"></div>`);
  else if (board[nx][ny].team != player || dataBlock(nx, ny) != 1) {
    $("#go").append(`<div class="go-kill" onclick="go(${x},${y},${nx},${ny})"
      style="${pos(nx, ny)}"></div>`);
  }
}
// Compute where a piece can go and render all the clickable squares
function control(x, y) {
  let boardXY = board[x][y];
  if (boardXY.frozen) return;
  if (player == boardXY.team && going == 0) {
    going = 2;
    // Compute where the piece can go and store the destinations in `res`
    var res = [];
    switch (boardXY.level) {
      case 0:
      case 1:
        var dx = [-1, 0, 1, 0], dy = [0, -1, 0, 1];
        for (let d = 0; d < 4; d++) {
          let nx = Number(x) + Number(dx[d]), ny = Number(y) + Number(dy[d]);
          while (passingQ(x, y, nx, ny)) {
            res.push([nx, ny]);
            nx += dx[d], ny += dy[d];
          }
          if (landingQ(x, y, nx, ny))
            res.push([nx, ny]);
        }
        break;
      case 2:
      case 3:
        var dx = [-1, -1, 1, 1], dy = [-1, 1, -1, 1];
        for (let d = 0; d < 4; d++) {
          let nx = Number(x) + Number(dx[d]), ny = Number(y) + Number(dy[d]);
          while (passingQ(x, y, nx, ny)) {
            res.push([nx, ny]);
            nx += dx[d], ny += dy[d];
          }
          if (landingQ(x, y, nx, ny))
            res.push([nx, ny]);
        }
        dx = [1, -1, 0, 0], dy = [0, 0, 1, -1];
        for (let d = 0; d < 4; d++) {
          let nx = Number(x) + dx[d], ny = Number(y) + dy[d];
          if (landingQ(x, y, nx, ny))
            res.push([nx, ny]);
        }
        break;
      case 4:
      case 5:
        var dx = [1, -1, 1, -1, 2, -2, 2, -2, 1, -1, 0, 0],
          dy = [2, 2, -2, -2, 1, 1, -1, -1, 0, 0, 1, -1];
        for (let d = 0; d < 12; d++) {
          let nx = Number(x) + Number(dx[d]), ny = Number(y) + Number(dy[d]);
          if (landingQ(x, y, nx, ny))
            res.push([nx, ny]);
        }
        break;
      case 6:
      case 7:
        // Standard BFS
        var dx = [1, -1, 0, 0], dy = [0, 0, 1, -1];
        var queue = [[x, y, 0]];
        var vis = new Map([[x * 1000 + y, true]]);
        while (queue.length != 0) {
          // Pop the head element of queue
          var node = queue[0];
          var x0 = node[0], y0 = node[1], t0 = node[2];
          queue.splice(0, 1);
          // Push new elements into queue
          for (let d = 0; d < 4; d++) {
            let nx = x0 + dx[d], ny = y0 + dy[d], nt = t0 + 1;
            // Visitedness check
            if (vis.has(nx * 1000 + ny)) continue;
            // Process
            vis.set(nx * 1000 + ny, true);
            if (landingQ(x, y, nx, ny))
              res.push([nx, ny]);
            // Push element
            if (passingQ(x, y, nx, ny) && nt <= 1) {
              queue.push([nx, ny, nt]);
            }
          }
        }
        break;
      case 9:
      case 10:
      case 11:
        var dx = [1, -1, 0, 0], dy = [0, 0, 1, -1];
        for (let d = 0; d < 4; d++) {
          let nx = Number(x) + dx[d], ny = Number(y) + dy[d];
          if (landingQ(x, y, nx, ny))
            res.push([nx, ny]);
        }
        break;
    }
    // Process effect of swiftness
    if (boardXY.potionSwiftness) {
      var dx = [1, -1, 0, 0], dy = [0, 0, 1, -1];
      var queue = [[x, y, 0]];
      var vis = new Map([[x * 1000 + y, true]]);
      while (queue.length != 0) {
        // Pop the head element of queue
        var node = queue[0];
        var x0 = node[0], y0 = node[1], t0 = node[2];
        queue.splice(0, 1);
        // Push new elements into queue
        for (let d = 0; d < 4; d++) {
          let nx = x0 + dx[d], ny = y0 + dy[d], nt = t0 + 1;
          // Visitedness check
          if (vis.has(nx * 1000 + ny)) continue;
          // Process
          vis.set(nx * 1000 + ny, true);
          if (landingQ(x, y, nx, ny))
            res.push([nx, ny]);
          // Push element
          if ((passingQ(x, y, nx, ny)) && nt <= 2) {
            queue.push([nx, ny, nt]);
          }
        }
      }
    }
    // Render the clickable green(or other colors) squares
    for (var point of res) controlHelper(x, y, point[0], point[1]);
  }
  if (going == 1) {
    $("#go").empty();
    going = 0;
  }
  if (going == 2) going = 1;
}

// Give the piece on (x, y) the damage of d
// Note: Remember to handle the case manually that the piece is knocked out
function damagePiece(x, y, d) {
  var boneFlag = false;
  for (var i in board[x][y].item) {
    var item = board[x][y].item[i];
    if (item == 14) {
      boneFlag = true;
      board[x][y].item.splice(i, 1);
      break;
    }
  }
  if (!boneFlag)
    board[x][y].blood -= Math.max(1, d - board[x][y].armor);
}

// The 3 functions below are just for displaying.
// They don't change the value of `board`, so you should change it manually.
// Just to move a piece without considering anything else
function movePiece(x, y, nx, ny) {
  var bxy = board[x][y];
  var ele = document.getElementById("piece" + String(Number(bxy.team) * 16 + Number(bxy.level)));
  ele.onclick = function () {
    control(nx, ny);
  };
  ele.onmouseover = function () {
    infoBox(nx, ny);
  };
  $(ele).css(posObj(nx, ny));
}
// Display a piece as dead (put it out of the board)
var killPiecePos = 0;
var kingAlive = [1, 1, 1]; // kingAlive[team] = if king of the team is alive
var killedNum = [0, 0, 0]; // killedNum[team] = number of killed pieces of the team
function killPiece(x, y) {
  var bxy = board[x][y];
  var ele = document.getElementById("piece" + String(Number(bxy.team) * 16 + Number(bxy.level)));
  if (bxy.level == 8) {
    kingAlive[bxy.team] = 0;
    // Nether Portal appears
    build(4, 4, 0);
    if (board[4][4] != -1) interworldTransport(4, 4);
  }
  if (kingAlive[bxy.team])
    $(ele).css(posObj((killPiecePos++) % n, n + 1));
  else
    $(ele).css("display", "none");
  ele.onclick = function () { };
  ele.onmouseover = function () { };
  $(ele).children(".sword-img").css("background", "none");
  $(ele).children(".armor-img").css("background", "none");
  $cell(x, y).empty();
  if (kingAlive[bxy.team])
    reviveList[curWorld].push([bxy, 5]); // `5` means reviving after 5 goes
  else killedNum[bxy.team]++;

  if (killedNum[0] == m) cAlert("<h2>白棋胜!</h2>");
  if (killedNum[1] == m) cAlert("<h2>黑棋胜!</h2>");
}
// Display a piece as alive (put it back in the board)
function revivePiece(i, nx, ny) {
  var bxy = reviveList[curWorld][i][0];
  var ele = document.getElementById("piece" + String(Number(bxy.team) * 16 + Number(bxy.level)));
  $(ele).css(posObj(nx, ny));
  ele.onclick = function () {
    control(nx, ny);
  };
  ele.onmouseover = function () {
    infoBox(nx, ny);
  }
  reviveList[curWorld].splice(i, 1);
  pickUp(nx, ny, nx, ny);
}

// Perform general operations necessary after using an item
function afterItem() {
  $("#go").empty();
  $("#control").fadeOut();
  going = 0;
}
// Perform general operations necessary after each go
function afterGo() {
  afterItem();

  player = 1 - player;
  $("#player").toggleClass("teami").toggleClass("teamii");

  // Generate supply
  turn++;
  if (Math.random() < genSupplyP) {
    var pt, px, py; // Type, X, Y (X, Y indicate its position in the board)
    // Generate pt(type) according to the weights
    var t = Math.floor(Math.random() * supplyW);
    for (var i in supplySprite)
      if (t >= supplySprite[i][2]) t -= supplySprite[i][2];
      else { pt = Number(i); break; }
    // Generate px, py(position)
    var cnt = 0;
    do {
      px = Math.floor(Math.random() * n);
      py = Math.floor(Math.random() * n);
      cnt++;
    } while ((!emptyQ(px, py) || dataSupply(px, py) != -1) && cnt < 100);
    if (cnt < 18) {
      $cell(px, py).attr("data-supply", pt)
        .html(`<div style="${spriteCss(supplySprite[pt], 36)}margin:auto;"></div>`);
      if (pt <= 2) genSupplyP = 0.33; // If a sword is produced, decrease genSupplyP to 1/3
    }
  }

  // Revive pieces
  for (var i in reviveList[curWorld]) {
    var item = reviveList[curWorld][i];
    item[1]--;
    if (item[1] == 0) {
      var rx, ry;
      if (item[0].team == 0) {
        rx = n - 1, ry = n - 1;
        while (!emptyQ(rx, ry)) {
          ry--;
          if (ry == -1) ry = n - 1, rx--;
        }
      }
      else {
        rx = 0, ry = 0;
        while (!emptyQ(rx, ry)) {
          ry++;
          if (ry == n) ry = 0, rx++;
        }
      }
      board[rx][ry] = newPiece({ team: item[0].team, level: item[0].level });
      revivePiece(i, rx, ry);
      if (board[rx][ry].team == 2)
        giveSupply(rx, ry, 4);
    }
  }

  // Decrease buff(from potions) duration
  for (var i = 0; i < n; i++) for (var j = 0; j < n; j++) if (board[i][j] != -1) {
    board[i][j].potionSwiftness = Math.max(0, board[i][j].potionSwiftness - 1);
    board[i][j].potionStrength = Math.max(0, board[i][j].potionStrength - 1);
    board[i][j].frozen = Math.max(0, board[i][j].frozen - 1);
    if (board[i][j].frozen == 0) $cell(i, j).children(".frozen-img").remove();
  }

  // Move Jasons automatically
  var vis = new Array();
  for (var i = 0; i < numJason; i++) vis.push(0);
  if (curWorld == 1) {
    for (var i = 0; i < n; i++) for (var j = 0; j < n; j++)
      if (board[i][j] != -1 && board[i][j].team == 2 && !vis[board[i][j].level]) {
        vis[board[i][j].level] = 1;
        // Attack
        var dx = [-1, 0, 1, -1, 1, -1, 0, 1], dy = [-1, -1, -1, 0, 0, 1, 1, 1];
        var attacked = false;
        for (var z = 0; z < 16; z++) {
          var d = Math.floor(Math.random() * 8);
          let nx = i + dx[d], ny = j + dy[d];
          while (passingQ(i, j, nx, ny)) nx += dx[d], ny += dy[d];
          if (inBoard(nx, ny) && board[nx][ny] != -1 && board[nx][ny].team <= 1) {
            var ele = $(`<img src="img/bone.png" class="jason-bone" style="${pos(i, j)}">`);
            ele.appendTo("body");
            setTimeout(function (ele) {
              ele.css(posObj(nx, ny));
              setTimeout(function (ele) {
                ele.remove();
                damagePiece(nx, ny, 6);
                if (board[nx][ny].blood <= 0) {
                  killPiece(nx, ny);
                  board[nx][ny] = -1;
                }
              }, 1000, ele);
            }, 100, ele);
            attacked = true;
            break;
          }
        }
        // Wander
        if (!attacked) {
          var d = Math.floor(Math.random() * 8);
          var loopCnt = 0;
          while (!emptyQ(i + dx[d], j + dy[d]) && loopCnt < 16)
            d = Math.floor(Math.random() * 8), loopCnt++;
          if (loopCnt < 16)
            go(i, j, i + dx[d], j + dy[d], true);
        }
      }
  }
}

// Give the supply whose ID is "supply" to the piece on (x, y)
function giveSupply(x, y, supply) {
  if (supply >= 0 && supply <= 2) { // Sword
    if (swordAttack[supply] >= board[x][y].attack) {
      board[x][y].attack = swordAttack[supply];
      // Display it on the piece
      $piece(x, y).children(".sword-img").css(spriteCssObj(supplySprite[supply], 15));
    }
  }
  else if (supply >= 3 && supply <= 5) { // Armor
    if (armorDefence[supply - 3] >= board[x][y].armor) {
      board[x][y].armor = armorDefence[supply - 3];
      $piece(x, y).children(".armor-img").css(spriteCssObj(supplySprite[supply], 15));
    }
  }
  else { // Item
    board[x][y].item.push(supply);
  }
}

// The piece on (x, y) picks up supply on (nx, ny)
function pickUp(x, y, nx, ny) {
  var supply = dataSupply(nx, ny);
  if (supply != -1) {
    giveSupply(x, y, supply);
    $cell(nx, ny).attr("data-supply", -1).html("");
  }
}

// Move a piece from (x, y) to (nx, ny)
function go(x, y, nx, ny, withoutAfterGo) {
  let bxy = board[x][y], nbxy = board[nx][ny];
  if (emptyQ(nx, ny)) { // Steps into empty square
    movePiece(x, y, nx, ny);
    pickUp(x, y, nx, ny);
    board[nx][ny] = board[x][y];
    board[x][y] = -1;
  }
  else if (nbxy != -1) { // Attack another piece
    nbxy = board[nx][ny]; bxy = board[x][y];
    damagePiece(nx, ny, board[x][y].attack + (board[x][y].potionStrength ? 2 : 0));
    if (nbxy.blood <= 0) { // Knock Out
      killPiece(nx, ny);
      bxy.attack = Math.max(bxy.attack, nbxy.attack), nbxy.attack = 0; // Transfer sword
      if (bxy.attack > initAttack)
        giveSupply(x, y, swordAttack.indexOf(bxy.attack));
      bxy.armor = Math.max(bxy.armor, nbxy.armor), nbxy.armor = 0; // Transfer armor
      if (bxy.armor > 0)
        giveSupply(x, y, armorDefence.indexOf(bxy.armor) + 3);
      bxy.item = bxy.item.concat(nbxy.item); // Transfer item
      movePiece(x, y, nx, ny);
      if (nbxy.team == 2) giveSupply(x, y, 14), giveSupply(x, y, 14);
      board[x][y] = -1; board[nx][ny] = bxy;
    }
  }
  else if (dataBlock(nx, ny) == 0) { // Enter Nether Portal
    interworldTransport(x, y);
  }
  else if (dataBlock(nx, ny) != -1) { // Distroy block
    destroy(nx, ny);
  }
  if (withoutAfterGo != true) afterGo();
}

// blockSprite[id] = [spriteX, spriteY]
var blockSprite = new Map([[0, [20, 1]], // Nether Portal
[12, [10, 60]], // Mossy Stone Bricks
[13, [18, 58]]]); // Bricks
// Put a block whose ID is `b` on (x, y)
function build(x, y, b) {
  $cell(x, y).empty().css(blockSpriteCssObj(blockSprite.get(b), 50))
    .attr("data-block", b);
  afterItem();
}
// Destroy the block on (x, y)
function destroy(x, y) {
  $cell(x, y).css("background", "none").attr("data-block", "-1");
}

function useItem(item, x, y) {
  switch (item) {
    case 6:
      for (var i = 0; i < n; i++) for (var j = 0; j < n; j++) {
        var dist = (i - x) * (i - x) + (j - y) * (j - y);
        // TNT explosion destroys blocks
        if (dist <= 4 && dataBlock(i, j) == 12) destroy(i, j);
        if (dist <= 1 && dataBlock(i, j) == 13) destroy(i, j);
        if (dist <= 10 && board[i][j] != -1) {
          // TNT explosion destroys ice (regardless of its team)
          if (board[i][j].frozen) {
            board[i][j].frozen = 0;
            $cell(i, j).empty();
          }
          // TNT hurts enemy's pieces
          if (board[i][j].team != board[x][y].team) {
            damagePiece(i, j, 11 - dist);
            if (board[i][j].blood <= 0) {
              killPiece(i, j);
              board[i][j] = -1;
            }
          }
        }
      }
      afterGo();
      break;
    case 7:
      board[x][y].blood = initBlood;
      afterItem();
      break;
    case 8:
      board[x][y].potionSwiftness = 8;
      afterItem();
      break;
    case 9:
      board[x][y].potionStrength = 8;
      afterItem();
      break;
    case 10:
      var dx = [1, 1, 1, 0, 0, -1, -1, -1], dy = [1, 0, -1, 1, -1, 1, 0, -1];
      for (var i = 0; i < 8; i++) {
        var nx = x + dx[i], ny = y + dy[i];
        if (inBoard(nx, ny) && board[nx][ny] != -1
          && board[nx][ny].team != board[x][y].team) {
          board[nx][ny].frozen += 8;
          // If there is supply on this square, it will disappear
          $cell(nx, ny).html(`<img class="frozen-img" src="img/frozen.png">`);
        }
      }
      afterGo();
      break;
    case 11:
      $("#go").empty();
      $("#control").fadeOut();
      for (var i = 0; i < n; i++) for (var j = 0; j < n; j++)
        if (emptyQ(i, j) || dataBlock(i, j) == 0)
          controlHelper(x, y, i, j);
      break;
    case 12:
    case 13:
      $("#control").fadeOut();
      $(".go-empty").each(function () {
        $(this).removeClass("go-empty").addClass("go-build");
        var orig = $(this).attr("onclick");
        var tmpstr = orig.replace(/^go\(\d*,\d*,(\d*),(\d*)\)$/ig, `$1 $2`);
        var tmparr = tmpstr.split(" ");
        if (!emptyQ(tmparr[0], tmparr[1])) $(this.remove());
        else {
          var pres = orig.replace(/^go\(\d*,\d*,(\d*),(\d*)\)$/ig, `build($1,$2,${item})`);
          $(this).attr("onclick", pres);
        }
      });
      $(".go-kill").remove();
      break;
    case 14:
      var dx = [-1, 0, 1, -1, 1, -1, 0, 1], dy = [-1, -1, -1, 0, 0, 1, 1, 1];
      var attacked = false;
      for (var d0 = Math.floor(Math.random() * 8); d0 <= 16; d0++) {
        var d = d0 % 8;
        let nx = x + dx[d], ny = y + dy[d];
        while (passingQ(x, y, nx, ny)) nx += dx[d], ny += dy[d];
        if (inBoard(nx, ny) && board[nx][ny] != -1 && board[nx][ny].team != board[x][y].team) {
          var ele = $(`<img src="img/bone.png" class="jason-bone" style="${pos(x, y)}">`);
          ele.appendTo("body");
          setTimeout(function (ele) {
            ele.css(posObj(nx, ny));
            setTimeout(function (ele) {
              ele.remove();
              damagePiece(nx, ny, 6);
              if (board[nx][ny].blood <= 0) {
                killPiece(nx, ny);
                board[nx][ny] = -1;
              }
            }, 1000, ele);
          }, 100, ele);
          attacked = true;
          break;
        }
      }
      afterItem();
      if (!attacked) {
        cAlert("无法找到攻击目标。");
        return;
      }
      break;
  }

  // Remove the item from the piece's "item" property
  for (var i = 0; i < board[x][y].item.length; i++)
    if (board[x][y].item[i] == item) {
      board[x][y].item.splice(i, 1);
      break;
    }
}

function assess() {
  var res = [kingAlive[0] * 400, kingAlive[1] * 400]; // Final result
  var weight = [100, 100, 110, 110, 45, 45, 110, 110, 600]; // Weights of each piece
  function func(board, world) {
    for (var i = 0; i < n; i++) for (var j = 0; j < n; j++) {
      if (board[i][j] == -1) continue;
      var t = board[i][j].team; // The piece's team
      if (t > 1) continue;
      var wt = weight[board[i][j].level]; // Weight of the current piece
      var addition = 0; // Additional score (equips, items, etc.)
      addition += Math.max(0, wt * 0.18 * (board[i][j].attack - 6)); // Swords
      addition += wt * 0.27 * (board[i][j].armor); // Armor
      var itm = new Array(); // tmp[i] = Number of item i that the piece has
      for (var k = 0; k < 50; k++) itm.push(0);
      for (var item of board[i][j].item) itm[item]++; // Count the items that the piece has
      addition += (Math.min(itm[6] * 15, 55) + itm[7] * 60
        + Math.min((itm[8] + itm[9]) * 10, 35)
        + Math.min((itm[10] + itm[11]) * 8, 15)); // Compute the additional score
      // The less blood it has, the less additional score it can get (its weight as well if king is dead)
      var bloodRatio = board[i][j].blood / initBlood;
      res[t] += (addition * bloodRatio + wt * (kingAlive[t] && board[i][j].level != 8 ? 1 : bloodRatio));
    }
    for (var item of reviveList[world]) {
      if (item[0].team <= 1)
        res[item[0].team] += weight[item[0].level] * 0.9;
    }
  }
  func(board, curWorld);
  func(alterBoard, 1 - curWorld);
  res = res.map((x) => (Math.round(x * 10) / 10));
  cAlert(`当前局面评估结果：<br>
  黑 <b style="color:#dc3545">${res[0]}：${res[1]}</b> 白<br>
  若现在结束比赛，可判${res[0] > res[1] ? "黑胜" : (res[0] < res[1] ? "白胜" : "平")}。`);
}

// Transport piece (x,y) to the other world (randomly)
function interworldTransport(x, y) {
  var tpx = 4, tpy = 4;
  while (alterBoard[tpx][tpy] != -1 ||
    Number($(alterHTML).eq(tpx).children("td").eq(tpy).attr("data-block")) != -1)
    tpx = Math.floor(Math.random() * n), tpy = Math.floor(Math.random() * n);
  var attrWorld = $piece(x, y).attr("data-world");
  $piece(x, y).attr("data-world", 1 - attrWorld);
  movePiece(x, y, tpx, tpy);
  alterBoard[tpx][tpy] = board[x][y];
  board[x][y] = -1;
}

function toggleWorld() {
  // Toggle variable
  curWorld = 1 - curWorld;
  var tmp;
  tmp = board, board = alterBoard, alterBoard = tmp;
  // Toggle HTML
  tmp = $("#board").html(), $("#board").html(alterHTML), alterHTML = tmp;
  // Toggle CSS
  $(`style[data-world]`).attr("type", "text/plain");
  $(`style[data-world="${curWorld}"]`).attr("type", "text/css");
  // Avoid cheating
  afterItem();
}